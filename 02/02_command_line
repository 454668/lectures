^T:  Command Line and Version Control
^ST: bash, git, and regex
^I:  Introduction to Programming for Public Policy
^SI: Intro Programming
^D:  October 3, 2016

+ Reminders
! First homework due tonight.  \\ Collected automatically at 1:30am.
! Next week's homework is also posted.

+++ The Command Line
''' Today is an `interlude.'  We have a long way to go with Python, and we'll continue on Wednesday.  But since you are already using the command line and git, we need to discuss these now.

+ The Fundamental Commands: Review
\Large
- \chred{pwd}:     print working directory
- \chred{cd}:      change directory
- \chred{mkdir}:   create a directory
- \chred{rm(dir)}: remove a file (directory)
- \chred{ls}:      list (files and folders)
- \chred{mv}:      move or rename a file
- \chred{python}:  run a python script
- \chred{man}:     read the `manual'
>0.5em
- \chred{ssh/scp}: secure connections (not in this course)

+ Going Further: The Commands
Don't memorize these, but be aware of `the sort of things' they do.
- \chred{echo}:    parrot back some text
- \chred{curl/wget}: retrieving web resources.
- \chred{cat, head, tail}: `concatenate' (dump) a file, or part of it
- \chred{less}:    page through a file
- \chred{grep}:    search for lines in a file
- \chred{sed}:     regular expression/replacement
- \chred{awk}:     simple scripts
- \chred{wc}:      count words or lines in file
- \chred{sort}:    sort a file
- \chred{chmod}:   change file `permissions'
- \chred{top}:     see what is running
- \chred{history}: what have you done!?
- \chred{git}:     version control, of course
- \chred{whoami}, \chred{hostname}, \&c.

+ Going Further: Piping and Scripting
- The power of the command line comes from the ability to quickly compose programs from these building blocks.
- There are four `connectors' to know:
--[\tt{|}]  \chred{pipe}: forward the output to the next command.
--[\tt{>}]  \chred{redirect output}: write to a file
--[\tt{>>}] \chred{redirect output}: \emph{append} to a file.
--[\tt{<}]  \chred{redirect input}: feed \emph{in} to command.
--[\tt{<< X}] \chred{read input}: read in from the command line `until X'

+ echo
- \tt{echo} just parrots everything that follows it:
` \pr echo hello world. \\ hello world.
- You could easily use this to write to a file... not like this!
` \pr echo for i in range(10): print(i) > my.py \\ -bash: \chred{syntax error} near unexpected token `('
- `Special' characters (\/, \$, (, ), etc.) need to be enclosed in quotes:
` \pr echo "for i in range(10): print(i)" > my.py \\ \pr python my.py

+ curl/wget
- \tt{curl} and \tt{wget} retrieve a web-page or other net resource \link{https://data.cityofchicago.org/Administration-Finance/Current-Employee-Names-Salaries-and-Position-Title/xzkq-xp2w}{[link]}:
` wget data.cityofchicago.org/api/views/xzkq-xp2w/rows.csv 
` curl data.cityofchicago.org/api/views/xzkq-xp2w/rows.csv -s -o salaries.csv
- The wget `-O' and curl `-o' `options' allow you to specify and output file name for the download.
-- And -s stands for `silent' -- see the \tt{man} pages.

+ cat/head/tail/less
- \tt{cat} dumps a file to the screen:
` \pr cat salaries.csv
- For very large files, better to `page through it', or check the beginning or end:
` \pr less salaries.csv
` \pr head -42 salaries.csv \# first 42 lines
` \pr tail -12 salaries.csv \#  last 12 lines
- With \tt{<< X}, one could write a small script ... uncommon.

+ grep [1 of 3]
- \tt{grep} is a `find in file'
` \pr grep EMANUEL salaries.csv
- You can also `reverse grep' with `-V.'
- \chred{grep is my favorite command.}  I hope you will enjoy it too!

+ grep [2 of 3]: Regular Expresion Special Characters 
Regular expressions (regex) is a shorthand, for complex pattern matches.
- Dramatically expands potential of grep.
*T: A bit quirky at first, but super useful!
* c l
* \tt{\^}          & Beginning of the line. \\
* \$            & End of line. \\
* \tt{\textbackslash}  & Turn off the next special character. \\
* \tt{[ ]}      & Any {\it contained} characters; use `x-y' for range. \\
* \tt{[\^{} ]}  & None of contained characters. \\
* \tt{.}        & Any single character. \\
* \tt{*}        & The preceding character/expression, any number of times. \\
* \tt{\textbackslash\string{x\textbackslash\string}}    & The preceding, $x$ times. \\
* \tt{x|y}      & x OR y. \\

+[fragile] grep [3 of 3]: Applying Regular Expressions
- How much does the mayor make? 
\begin{tcolorbox}
\pr \verb|grep '^\"EMA' salaries.csv|
\end{tcolorbox}
- Who makes more than \$200k?
\begin{tcolorbox}
\pr \verb|grep '\$[2-9][0-9]\{5\}\.' salaries.csv|
\end{tcolorbox}

+ wc: word count
- wc allows you to count the number of bytes (-c), number of words (-w) or number of lines (-l) in a file:
` \pr wc -l salaries.csv \# by far the most useful
- How many police offers are on the streets of Chicago?
` \pr grep -i "police officer" salaries.csv | wc -l
- How many of them are detectives?
` \pr grep "POLICE.*DETECTIVE" salaries.csv | wc -l

+ sed
- sed allows for simple, regex find and replace
- If you learn \tt{vim} it is the same syntax:
` \pr sed 's/find/replace/g' salaries.csv
- Here, the \tt{s} means `search' and the \tt{g} means global/all occurrences in a line.  For instance, remove the \$ signs:
` \pr grep '\$' salaries.csv | sed 's/\$//g' 

+ sort
- sort sorts your file, with many options.
- Try to choose out the highest 20 municipal salaries in Chicago...
-- man: \tt{-k} for key, \tt{-r} for reverse, \tt{-t} for delimiter, \tt{-n} for numeric.

+ chmod
- chmod allows you to change the permissions of a file
- Each file has separate `permissions' for whether you (u), people in its `group' (g), or anyone (o), can read (r), write (w), or execute (x) the file.  You can add (+), remove (-), or set (=) permissions.
- Most often, use it to make a script executable, perhaps just for you:
` \pr cat my.py \\ \#!/usr/bin/env python \\ print("hello world") \\\pr chmod u+x my.py  \\ \pr ./my.py \# don't need `python' \\ hello world

+ A few more
- \tt{diff} shows you any differences between two files
- \tt{top} allows you to find out which programs are using the most resources (processor, memory)...
- \tt{hostname} shows you the current computer you're on.
- \tt{history} displays recent commands.
- \tt{awk} has a useful (but abstruse) scripting capabilities.
- \tt{column} will align columns.
- \chred{\tt{git}} is a powerful tool for versioning files!
>1em
- Any missing commands can be installed through the cygwin installer or with home brew on Mac.  (Or apt-get/yum on Linux.)

+++ Version Control: Git

+ What is version control?  Why use it?
- Perhaps a familiar story below, for paper drafts.
- What if several people need to be able to edit \emph{simultaneously}.
- What if there are many different files that depend on eachother being at a specific version, all of which may be changed?
! Version Control Systems (VCS) maintain a history and facilitate collaborative editing.
>1em
[PIC OF COLLEGE DIRECTORY]

+ What is git?  GitHub?
- Git is \emph{the} modern VCS, designed by Linus Torvalds (creator of Linux).
- Git is \emph{distributed}: everyone has a copy of the entire history.
- Git maintains a history of meaningful `commits,' allows for \emph{branches} (large scale modifications) and merges.
-- branch: side project that may break everything, `merge' when complete.
- Allows you to return to a previous (consistent) version, or leap between branches.
- However, it is often useful to maintain a master copy on a server where anyone can access it or `push' their changes: GitHub.
- GitHub is a really nice web \chred{interface} to a lot of git's functionality.
../img/git_github.pdf:0.6

+ Git Commands 
You'll need these from day one:
- \chred{git init}:   create a repository in this directory
- \chred{git clone}:  download repository
- \chred{git add}:    add a file to `staging' area
- \chred{git status}: view status of all files
- \chred{git commit}: commit staged files to history
- \chred{git push}:   upload all changes to a remote server
- \chred{git log}:    show the history

+ A Standard Sequence \tright{Do in Terminal.}
Start with a single user and a single thread of edits:
# Download your homework skeleton:
#- \tt{git clone git@github.com:harris-ippp/hw-1-JamesSaxon.git}
# Make your edits with Atom or vim.
# Add files to the `staging' area, and commit them; check the status and log to see that it worked:
#- \tt{git add q1.py}
#- \tt{git status \# is everything there?}
#- \tt{git commit -m "started question 1"}
#- \tt{git log \# now all part of the commit history?}
# Upload it to the server:
#- \tt{git push}
Then repeat steps 2-4 as you go. \\
\visible<2>{\hspace{3.2em}\huge{\chred{This is what you'll use regularly.}}}

+ Further Assorted Commands
However, there is tremendous flexibility:
- \chred{git pull}:   download and merge updates from a remote server
- \chred{git fetch}:  just downlaod updates from a remote server
- \chred{git reset}:  move 
- \chred{git revert}: de-stage 
- \chred{git checkout}: switch to a different branch
- \chred{git branch}: show or create a branch
- \chred{git merge}:  merge one branch to another.
- \chred{git stash}: creates temporary $\unsim$branch; revert to a clean directory.
- \chred{git drop}:  get rid of the stash (gone forever)
- \chred{git pop}:   retrieve the changes in the stash.

+ Using Branches
Use `branches' to work on projects that might disrupt the `master' (which should always work):
# Download the project:
#- \tt{git clone git@github.com:JamesSaxon/test.git}
# Create a new branch:
#- \tt{git checkout -b my\_branch} 
#- Or \tt{git branch my\_branch}, then \tt{git checkout my\_branch}.
# Modify it as desired; stage (\tt{add}) and commit as before.
# Return to the master branch:
#- \tt{git checkout master}
# Merge the other branch in:
#- \tt{git merge my\_branch}
#- May require editing by hand if there are direct conflicts.
# Stage and commit master.
# Delete the old branch:
#- \tt{git branch -d my\_branch}

+ Collaborating with Git
# Grab a repository: 
#- \tt{git clone git@github.com:JamesSaxon/test.git}
# Make some changes and commit them.  In the meantime, your collaborator does the same.
# \tt{pull} updates down from the server, only to find that they conflict.  Resolve the conflicts and recommit.
# Push back up to the server.
#- \tt{git push}

